/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { usersBan } from "../funcs/usersBan.js";
import { usersCount } from "../funcs/usersCount.js";
import { usersCreate } from "../funcs/usersCreate.js";
import { usersDelete } from "../funcs/usersDelete.js";
import { usersDeleteBackupCodes } from "../funcs/usersDeleteBackupCodes.js";
import { usersDeleteExternalAccount } from "../funcs/usersDeleteExternalAccount.js";
import { usersDeletePasskey } from "../funcs/usersDeletePasskey.js";
import { usersDeleteProfileImage } from "../funcs/usersDeleteProfileImage.js";
import { usersDeleteTOTP } from "../funcs/usersDeleteTOTP.js";
import { usersDeleteWeb3Wallet } from "../funcs/usersDeleteWeb3Wallet.js";
import { usersDisableMfa } from "../funcs/usersDisableMfa.js";
import { usersGet } from "../funcs/usersGet.js";
import { usersGetInstanceOrganizationMemberships } from "../funcs/usersGetInstanceOrganizationMemberships.js";
import { usersGetOAuthAccessToken } from "../funcs/usersGetOAuthAccessToken.js";
import { usersGetOrganizationInvitations } from "../funcs/usersGetOrganizationInvitations.js";
import { usersGetOrganizationMemberships } from "../funcs/usersGetOrganizationMemberships.js";
import { usersList } from "../funcs/usersList.js";
import { usersLock } from "../funcs/usersLock.js";
import { usersSetProfileImage } from "../funcs/usersSetProfileImage.js";
import { usersUnban } from "../funcs/usersUnban.js";
import { usersUnlock } from "../funcs/usersUnlock.js";
import { usersUpdate } from "../funcs/usersUpdate.js";
import { usersUpdateMetadata } from "../funcs/usersUpdateMetadata.js";
import { usersVerifyPassword } from "../funcs/usersVerifyPassword.js";
import { usersVerifyTotp } from "../funcs/usersVerifyTotp.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Users extends ClientSDK {
  /**
   * List all users
   *
   * @remarks
   * Returns a list of all users.
   * The users are returned sorted by creation date, with the newest users appearing first.
   */
  async list(
    request: operations.GetUserListRequest,
    options?: RequestOptions,
  ): Promise<Array<components.User>> {
    return unwrapAsync(usersList(
      this,
      request,
      options,
    ));
  }

  /**
   * Create a new user
   *
   * @remarks
   * Creates a new user. Your user management settings determine how you should setup your user model.
   *
   * Any email address and phone number created using this method will be marked as verified.
   *
   * Note: If you are performing a migration, check out our guide on [zero downtime migrations](https://clerk.com/docs/deployments/migrate-overview).
   *
   * A rate limit rule of 20 requests per 10 seconds is applied to this endpoint.
   */
  async create(
    request: operations.CreateUserRequestBody,
    options?: RequestOptions,
  ): Promise<components.User> {
    return unwrapAsync(usersCreate(
      this,
      request,
      options,
    ));
  }

  /**
   * Count users
   *
   * @remarks
   * Returns a total count of all users that match the given filtering criteria.
   */
  async count(
    request: operations.GetUsersCountRequest,
    options?: RequestOptions,
  ): Promise<components.TotalCount> {
    return unwrapAsync(usersCount(
      this,
      request,
      options,
    ));
  }

  /**
   * Retrieve a user
   *
   * @remarks
   * Retrieve the details of a user
   */
  async get(
    request: operations.GetUserRequest,
    options?: RequestOptions,
  ): Promise<components.User> {
    return unwrapAsync(usersGet(
      this,
      request,
      options,
    ));
  }

  /**
   * Update a user
   *
   * @remarks
   * Update a user's attributes.
   *
   * You can set the user's primary contact identifiers (email address and phone numbers) by updating the `primary_email_address_id` and `primary_phone_number_id` attributes respectively.
   * Both IDs should correspond to verified identifications that belong to the user.
   *
   * You can remove a user's username by setting the username attribute to null or the blank string "".
   * This is a destructive action; the identification will be deleted forever.
   * Usernames can be removed only if they are optional in your instance settings and there's at least one other identifier which can be used for authentication.
   *
   * This endpoint allows changing a user's password. When passing the `password` parameter directly you have two further options.
   * You can ignore the password policy checks for your instance by setting the `skip_password_checks` parameter to `true`.
   * You can also choose to sign the user out of all their active sessions on any device once the password is updated. Just set `sign_out_of_other_sessions` to `true`.
   */
  async update(
    request: operations.UpdateUserRequest,
    options?: RequestOptions,
  ): Promise<components.User> {
    return unwrapAsync(usersUpdate(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete a user
   *
   * @remarks
   * Delete the specified user
   */
  async delete(
    request: operations.DeleteUserRequest,
    options?: RequestOptions,
  ): Promise<components.DeletedObject> {
    return unwrapAsync(usersDelete(
      this,
      request,
      options,
    ));
  }

  /**
   * Ban a user
   *
   * @remarks
   * Marks the given user as banned, which means that all their sessions are revoked and they are not allowed to sign in again.
   */
  async ban(
    request: operations.BanUserRequest,
    options?: RequestOptions,
  ): Promise<components.User> {
    return unwrapAsync(usersBan(
      this,
      request,
      options,
    ));
  }

  /**
   * Unban a user
   *
   * @remarks
   * Removes the ban mark from the given user.
   */
  async unban(
    request: operations.UnbanUserRequest,
    options?: RequestOptions,
  ): Promise<components.User> {
    return unwrapAsync(usersUnban(
      this,
      request,
      options,
    ));
  }

  /**
   * Lock a user
   *
   * @remarks
   * Marks the given user as locked, which means they are not allowed to sign in again until the lock expires.
   * Lock duration can be configured in the instance's restrictions settings.
   */
  async lock(
    request: operations.LockUserRequest,
    options?: RequestOptions,
  ): Promise<components.User> {
    return unwrapAsync(usersLock(
      this,
      request,
      options,
    ));
  }

  /**
   * Unlock a user
   *
   * @remarks
   * Removes the lock from the given user.
   */
  async unlock(
    request: operations.UnlockUserRequest,
    options?: RequestOptions,
  ): Promise<components.User> {
    return unwrapAsync(usersUnlock(
      this,
      request,
      options,
    ));
  }

  /**
   * Set user profile image
   *
   * @remarks
   * Update a user's profile image
   */
  async setProfileImage(
    request: operations.SetUserProfileImageRequest,
    options?: RequestOptions,
  ): Promise<components.User> {
    return unwrapAsync(usersSetProfileImage(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete user profile image
   *
   * @remarks
   * Delete a user's profile image
   */
  async deleteProfileImage(
    request: operations.DeleteUserProfileImageRequest,
    options?: RequestOptions,
  ): Promise<components.User> {
    return unwrapAsync(usersDeleteProfileImage(
      this,
      request,
      options,
    ));
  }

  /**
   * Merge and update a user's metadata
   *
   * @remarks
   * Update a user's metadata attributes by merging existing values with the provided parameters.
   *
   * This endpoint behaves differently than the *Update a user* endpoint.
   * Metadata values will not be replaced entirely.
   * Instead, a deep merge will be performed.
   * Deep means that any nested JSON objects will be merged as well.
   *
   * You can remove metadata keys at any level by setting their value to `null`.
   */
  async updateMetadata(
    request: operations.UpdateUserMetadataRequest,
    options?: RequestOptions,
  ): Promise<components.User> {
    return unwrapAsync(usersUpdateMetadata(
      this,
      request,
      options,
    ));
  }

  /**
   * Retrieve the OAuth access token of a user
   *
   * @remarks
   * Fetch the corresponding OAuth access token for a user that has previously authenticated with a particular OAuth provider.
   * For OAuth 2.0, if the access token has expired and we have a corresponding refresh token, the access token will be refreshed transparently the new one will be returned.
   */
  async getOAuthAccessToken(
    request: operations.GetOAuthAccessTokenRequest,
    options?: RequestOptions,
  ): Promise<Array<components.OAuthAccessToken>> {
    return unwrapAsync(usersGetOAuthAccessToken(
      this,
      request,
      options,
    ));
  }

  /**
   * Retrieve all memberships for a user
   *
   * @remarks
   * Retrieve a paginated list of the user's organization memberships
   */
  async getOrganizationMemberships(
    request: operations.UsersGetOrganizationMembershipsRequest,
    options?: RequestOptions,
  ): Promise<components.OrganizationMemberships> {
    return unwrapAsync(usersGetOrganizationMemberships(
      this,
      request,
      options,
    ));
  }

  /**
   * Retrieve all invitations for a user
   *
   * @remarks
   * Retrieve a paginated list of the user's organization invitations
   */
  async getOrganizationInvitations(
    request: operations.UsersGetOrganizationInvitationsRequest,
    options?: RequestOptions,
  ): Promise<components.OrganizationInvitationsWithPublicOrganizationData> {
    return unwrapAsync(usersGetOrganizationInvitations(
      this,
      request,
      options,
    ));
  }

  /**
   * Verify the password of a user
   *
   * @remarks
   * Check that the user's password matches the supplied input.
   * Useful for custom auth flows and re-verification.
   */
  async verifyPassword(
    request: operations.VerifyPasswordRequest,
    options?: RequestOptions,
  ): Promise<operations.VerifyPasswordResponseBody> {
    return unwrapAsync(usersVerifyPassword(
      this,
      request,
      options,
    ));
  }

  /**
   * Verify a TOTP or backup code for a user
   *
   * @remarks
   * Verify that the provided TOTP or backup code is valid for the user.
   * Verifying a backup code will result it in being consumed (i.e. it will
   * become invalid).
   * Useful for custom auth flows and re-verification.
   */
  async verifyTotp(
    request: operations.VerifyTOTPRequest,
    options?: RequestOptions,
  ): Promise<operations.VerifyTOTPResponseBody> {
    return unwrapAsync(usersVerifyTotp(
      this,
      request,
      options,
    ));
  }

  /**
   * Disable a user's MFA methods
   *
   * @remarks
   * Disable all of a user's MFA methods (e.g. OTP sent via SMS, TOTP on their authenticator app) at once.
   */
  async disableMfa(
    request: operations.DisableMFARequest,
    options?: RequestOptions,
  ): Promise<operations.DisableMFAResponseBody> {
    return unwrapAsync(usersDisableMfa(
      this,
      request,
      options,
    ));
  }

  /**
   * Disable all user's Backup codes
   *
   * @remarks
   * Disable all of a user's backup codes.
   */
  async deleteBackupCodes(
    request: operations.DeleteBackupCodeRequest,
    options?: RequestOptions,
  ): Promise<operations.DeleteBackupCodeResponseBody> {
    return unwrapAsync(usersDeleteBackupCodes(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete a user passkey
   *
   * @remarks
   * Delete the passkey identification for a given user and notify them through email.
   */
  async deletePasskey(
    request: operations.UserPasskeyDeleteRequest,
    options?: RequestOptions,
  ): Promise<components.DeletedObject> {
    return unwrapAsync(usersDeletePasskey(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete a user web3 wallet
   *
   * @remarks
   * Delete the web3 wallet identification for a given user.
   */
  async deleteWeb3Wallet(
    request: operations.UserWeb3WalletDeleteRequest,
    options?: RequestOptions,
  ): Promise<components.DeletedObject> {
    return unwrapAsync(usersDeleteWeb3Wallet(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete all the user's TOTPs
   *
   * @remarks
   * Deletes all of the user's TOTPs.
   */
  async deleteTOTP(
    request: operations.DeleteTOTPRequest,
    options?: RequestOptions,
  ): Promise<operations.DeleteTOTPResponseBody> {
    return unwrapAsync(usersDeleteTOTP(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete External Account
   *
   * @remarks
   * Delete an external account by ID.
   */
  async deleteExternalAccount(
    request: operations.DeleteExternalAccountRequest,
    options?: RequestOptions,
  ): Promise<components.DeletedObject> {
    return unwrapAsync(usersDeleteExternalAccount(
      this,
      request,
      options,
    ));
  }

  /**
   * Get a list of all organization memberships within an instance.
   *
   * @remarks
   * Retrieves all organization user memberships for the given instance.
   */
  async getInstanceOrganizationMemberships(
    request: operations.InstanceGetOrganizationMembershipsRequest,
    options?: RequestOptions,
  ): Promise<components.OrganizationMemberships> {
    return unwrapAsync(usersGetInstanceOrganizationMemberships(
      this,
      request,
      options,
    ));
  }
}
