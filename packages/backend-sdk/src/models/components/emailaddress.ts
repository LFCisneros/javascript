/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { catchUnrecognizedEnum, ClosedEnum, OpenEnum, Unrecognized } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  IdentificationLink,
  IdentificationLink$inboundSchema,
  IdentificationLink$Outbound,
  IdentificationLink$outboundSchema,
} from './identificationlink.js';

/**
 * String representing the object's type. Objects of the same type share the same value.
 *
 * @remarks
 */
export const EmailAddressObject = {
  EmailAddress: 'email_address',
} as const;
/**
 * String representing the object's type. Objects of the same type share the same value.
 *
 * @remarks
 */
export type EmailAddressObject = OpenEnum<typeof EmailAddressObject>;

export const TicketVerificationStatus = {
  Unverified: 'unverified',
  Verified: 'verified',
  Expired: 'expired',
} as const;
export type TicketVerificationStatus = ClosedEnum<typeof TicketVerificationStatus>;

export const TicketVerificationStrategy = {
  Ticket: 'ticket',
} as const;
export type TicketVerificationStrategy = OpenEnum<typeof TicketVerificationStrategy>;

export type Ticket = {
  status: TicketVerificationStatus;
  strategy: TicketVerificationStrategy;
  attempts: number | null;
  expireAt: number | null;
  verifiedAtClient?: string | null | undefined;
};

export const FromOAuthVerificationStatus = {
  Unverified: 'unverified',
  Verified: 'verified',
} as const;
export type FromOAuthVerificationStatus = ClosedEnum<typeof FromOAuthVerificationStatus>;

export type ErrorMeta = {};

export type ErrorClerkError = {
  message: string;
  longMessage: string;
  code: string;
  meta?: ErrorMeta | undefined;
  clerkTraceId?: string | undefined;
};

export type ErrorT = ErrorClerkError;

export type FromOAuth = {
  status: FromOAuthVerificationStatus;
  strategy: string;
  error?: ErrorClerkError | null | undefined;
  expireAt: number | null;
  attempts: number | null;
  verifiedAtClient?: string | null | undefined;
};

export const AdminVerificationStatus = {
  Verified: 'verified',
} as const;
export type AdminVerificationStatus = ClosedEnum<typeof AdminVerificationStatus>;

export const VerificationStrategy = {
  Admin: 'admin',
} as const;
export type VerificationStrategy = OpenEnum<typeof VerificationStrategy>;

export type Admin = {
  status: AdminVerificationStatus;
  strategy: VerificationStrategy;
  attempts: number | null;
  expireAt: number | null;
  verifiedAtClient?: string | null | undefined;
};

export const VerificationStatus = {
  Unverified: 'unverified',
  Verified: 'verified',
  Failed: 'failed',
  Expired: 'expired',
} as const;
export type VerificationStatus = ClosedEnum<typeof VerificationStatus>;

export const Strategy = {
  PhoneCode: 'phone_code',
  EmailCode: 'email_code',
  ResetPasswordEmailCode: 'reset_password_email_code',
} as const;
export type Strategy = OpenEnum<typeof Strategy>;

export type Otp = {
  status: VerificationStatus;
  strategy: Strategy;
  attempts: number | null;
  expireAt: number | null;
  verifiedAtClient?: string | null | undefined;
};

export type Verification = Otp | Admin | Ticket | FromOAuth;

/**
 * Success
 */
export type EmailAddress = {
  id?: string | undefined;
  /**
   * String representing the object's type. Objects of the same type share the same value.
   *
   * @remarks
   */
  object: EmailAddressObject;
  emailAddress: string;
  reserved: boolean;
  verification: Otp | Admin | Ticket | FromOAuth | null;
  linkedTo: Array<IdentificationLink>;
  /**
   * Indicates whether this email address domain matches an active enterprise connection.
   *
   * @remarks
   */
  matchesSsoConnection?: boolean | undefined;
  /**
   * Unix timestamp of creation
   *
   * @remarks
   */
  createdAt: number;
  /**
   * Unix timestamp of creation
   *
   * @remarks
   */
  updatedAt: number;
};

/** @internal */
export const EmailAddressObject$inboundSchema: z.ZodType<EmailAddressObject, z.ZodTypeDef, unknown> = z.union([
  z.nativeEnum(EmailAddressObject),
  z.string().transform(catchUnrecognizedEnum),
]);

/** @internal */
export const EmailAddressObject$outboundSchema: z.ZodType<EmailAddressObject, z.ZodTypeDef, EmailAddressObject> =
  z.union([z.nativeEnum(EmailAddressObject), z.string().and(z.custom<Unrecognized<string>>())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EmailAddressObject$ {
  /** @deprecated use `EmailAddressObject$inboundSchema` instead. */
  export const inboundSchema = EmailAddressObject$inboundSchema;
  /** @deprecated use `EmailAddressObject$outboundSchema` instead. */
  export const outboundSchema = EmailAddressObject$outboundSchema;
}

/** @internal */
export const TicketVerificationStatus$inboundSchema: z.ZodNativeEnum<typeof TicketVerificationStatus> =
  z.nativeEnum(TicketVerificationStatus);

/** @internal */
export const TicketVerificationStatus$outboundSchema: z.ZodNativeEnum<typeof TicketVerificationStatus> =
  TicketVerificationStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TicketVerificationStatus$ {
  /** @deprecated use `TicketVerificationStatus$inboundSchema` instead. */
  export const inboundSchema = TicketVerificationStatus$inboundSchema;
  /** @deprecated use `TicketVerificationStatus$outboundSchema` instead. */
  export const outboundSchema = TicketVerificationStatus$outboundSchema;
}

/** @internal */
export const TicketVerificationStrategy$inboundSchema: z.ZodType<TicketVerificationStrategy, z.ZodTypeDef, unknown> =
  z.union([z.nativeEnum(TicketVerificationStrategy), z.string().transform(catchUnrecognizedEnum)]);

/** @internal */
export const TicketVerificationStrategy$outboundSchema: z.ZodType<
  TicketVerificationStrategy,
  z.ZodTypeDef,
  TicketVerificationStrategy
> = z.union([z.nativeEnum(TicketVerificationStrategy), z.string().and(z.custom<Unrecognized<string>>())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TicketVerificationStrategy$ {
  /** @deprecated use `TicketVerificationStrategy$inboundSchema` instead. */
  export const inboundSchema = TicketVerificationStrategy$inboundSchema;
  /** @deprecated use `TicketVerificationStrategy$outboundSchema` instead. */
  export const outboundSchema = TicketVerificationStrategy$outboundSchema;
}

/** @internal */
export const Ticket$inboundSchema: z.ZodType<Ticket, z.ZodTypeDef, unknown> = z
  .object({
    status: TicketVerificationStatus$inboundSchema,
    strategy: TicketVerificationStrategy$inboundSchema,
    attempts: z.nullable(z.number().int()),
    expire_at: z.nullable(z.number().int()),
    verified_at_client: z.nullable(z.string()).optional(),
  })
  .transform(v => {
    return remap$(v, {
      expire_at: 'expireAt',
      verified_at_client: 'verifiedAtClient',
    });
  });

/** @internal */
export type Ticket$Outbound = {
  status: string;
  strategy: string;
  attempts: number | null;
  expire_at: number | null;
  verified_at_client?: string | null | undefined;
};

/** @internal */
export const Ticket$outboundSchema: z.ZodType<Ticket$Outbound, z.ZodTypeDef, Ticket> = z
  .object({
    status: TicketVerificationStatus$outboundSchema,
    strategy: TicketVerificationStrategy$outboundSchema,
    attempts: z.nullable(z.number().int()),
    expireAt: z.nullable(z.number().int()),
    verifiedAtClient: z.nullable(z.string()).optional(),
  })
  .transform(v => {
    return remap$(v, {
      expireAt: 'expire_at',
      verifiedAtClient: 'verified_at_client',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Ticket$ {
  /** @deprecated use `Ticket$inboundSchema` instead. */
  export const inboundSchema = Ticket$inboundSchema;
  /** @deprecated use `Ticket$outboundSchema` instead. */
  export const outboundSchema = Ticket$outboundSchema;
  /** @deprecated use `Ticket$Outbound` instead. */
  export type Outbound = Ticket$Outbound;
}

export function ticketToJSON(ticket: Ticket): string {
  return JSON.stringify(Ticket$outboundSchema.parse(ticket));
}

export function ticketFromJSON(jsonString: string): SafeParseResult<Ticket, SDKValidationError> {
  return safeParse(jsonString, x => Ticket$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Ticket' from JSON`);
}

/** @internal */
export const FromOAuthVerificationStatus$inboundSchema: z.ZodNativeEnum<typeof FromOAuthVerificationStatus> =
  z.nativeEnum(FromOAuthVerificationStatus);

/** @internal */
export const FromOAuthVerificationStatus$outboundSchema: z.ZodNativeEnum<typeof FromOAuthVerificationStatus> =
  FromOAuthVerificationStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FromOAuthVerificationStatus$ {
  /** @deprecated use `FromOAuthVerificationStatus$inboundSchema` instead. */
  export const inboundSchema = FromOAuthVerificationStatus$inboundSchema;
  /** @deprecated use `FromOAuthVerificationStatus$outboundSchema` instead. */
  export const outboundSchema = FromOAuthVerificationStatus$outboundSchema;
}

/** @internal */
export const ErrorMeta$inboundSchema: z.ZodType<ErrorMeta, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type ErrorMeta$Outbound = {};

/** @internal */
export const ErrorMeta$outboundSchema: z.ZodType<ErrorMeta$Outbound, z.ZodTypeDef, ErrorMeta> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ErrorMeta$ {
  /** @deprecated use `ErrorMeta$inboundSchema` instead. */
  export const inboundSchema = ErrorMeta$inboundSchema;
  /** @deprecated use `ErrorMeta$outboundSchema` instead. */
  export const outboundSchema = ErrorMeta$outboundSchema;
  /** @deprecated use `ErrorMeta$Outbound` instead. */
  export type Outbound = ErrorMeta$Outbound;
}

export function errorMetaToJSON(errorMeta: ErrorMeta): string {
  return JSON.stringify(ErrorMeta$outboundSchema.parse(errorMeta));
}

export function errorMetaFromJSON(jsonString: string): SafeParseResult<ErrorMeta, SDKValidationError> {
  return safeParse(
    jsonString,
    x => ErrorMeta$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ErrorMeta' from JSON`,
  );
}

/** @internal */
export const ErrorClerkError$inboundSchema: z.ZodType<ErrorClerkError, z.ZodTypeDef, unknown> = z
  .object({
    message: z.string(),
    long_message: z.string(),
    code: z.string(),
    meta: z.lazy(() => ErrorMeta$inboundSchema).optional(),
    clerk_trace_id: z.string().optional(),
  })
  .transform(v => {
    return remap$(v, {
      long_message: 'longMessage',
      clerk_trace_id: 'clerkTraceId',
    });
  });

/** @internal */
export type ErrorClerkError$Outbound = {
  message: string;
  long_message: string;
  code: string;
  meta?: ErrorMeta$Outbound | undefined;
  clerk_trace_id?: string | undefined;
};

/** @internal */
export const ErrorClerkError$outboundSchema: z.ZodType<ErrorClerkError$Outbound, z.ZodTypeDef, ErrorClerkError> = z
  .object({
    message: z.string(),
    longMessage: z.string(),
    code: z.string(),
    meta: z.lazy(() => ErrorMeta$outboundSchema).optional(),
    clerkTraceId: z.string().optional(),
  })
  .transform(v => {
    return remap$(v, {
      longMessage: 'long_message',
      clerkTraceId: 'clerk_trace_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ErrorClerkError$ {
  /** @deprecated use `ErrorClerkError$inboundSchema` instead. */
  export const inboundSchema = ErrorClerkError$inboundSchema;
  /** @deprecated use `ErrorClerkError$outboundSchema` instead. */
  export const outboundSchema = ErrorClerkError$outboundSchema;
  /** @deprecated use `ErrorClerkError$Outbound` instead. */
  export type Outbound = ErrorClerkError$Outbound;
}

export function errorClerkErrorToJSON(errorClerkError: ErrorClerkError): string {
  return JSON.stringify(ErrorClerkError$outboundSchema.parse(errorClerkError));
}

export function errorClerkErrorFromJSON(jsonString: string): SafeParseResult<ErrorClerkError, SDKValidationError> {
  return safeParse(
    jsonString,
    x => ErrorClerkError$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ErrorClerkError' from JSON`,
  );
}

/** @internal */
export const ErrorT$inboundSchema: z.ZodType<ErrorT, z.ZodTypeDef, unknown> = z.lazy(
  () => ErrorClerkError$inboundSchema,
);

/** @internal */
export type ErrorT$Outbound = ErrorClerkError$Outbound;

/** @internal */
export const ErrorT$outboundSchema: z.ZodType<ErrorT$Outbound, z.ZodTypeDef, ErrorT> = z.lazy(
  () => ErrorClerkError$outboundSchema,
);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ErrorT$ {
  /** @deprecated use `ErrorT$inboundSchema` instead. */
  export const inboundSchema = ErrorT$inboundSchema;
  /** @deprecated use `ErrorT$outboundSchema` instead. */
  export const outboundSchema = ErrorT$outboundSchema;
  /** @deprecated use `ErrorT$Outbound` instead. */
  export type Outbound = ErrorT$Outbound;
}

export function errorToJSON(errorT: ErrorT): string {
  return JSON.stringify(ErrorT$outboundSchema.parse(errorT));
}

export function errorFromJSON(jsonString: string): SafeParseResult<ErrorT, SDKValidationError> {
  return safeParse(jsonString, x => ErrorT$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'ErrorT' from JSON`);
}

/** @internal */
export const FromOAuth$inboundSchema: z.ZodType<FromOAuth, z.ZodTypeDef, unknown> = z
  .object({
    status: FromOAuthVerificationStatus$inboundSchema,
    strategy: z.string(),
    error: z.nullable(z.lazy(() => ErrorClerkError$inboundSchema)).optional(),
    expire_at: z.nullable(z.number().int()),
    attempts: z.nullable(z.number().int()),
    verified_at_client: z.nullable(z.string()).optional(),
  })
  .transform(v => {
    return remap$(v, {
      expire_at: 'expireAt',
      verified_at_client: 'verifiedAtClient',
    });
  });

/** @internal */
export type FromOAuth$Outbound = {
  status: string;
  strategy: string;
  error?: ErrorClerkError$Outbound | null | undefined;
  expire_at: number | null;
  attempts: number | null;
  verified_at_client?: string | null | undefined;
};

/** @internal */
export const FromOAuth$outboundSchema: z.ZodType<FromOAuth$Outbound, z.ZodTypeDef, FromOAuth> = z
  .object({
    status: FromOAuthVerificationStatus$outboundSchema,
    strategy: z.string(),
    error: z.nullable(z.lazy(() => ErrorClerkError$outboundSchema)).optional(),
    expireAt: z.nullable(z.number().int()),
    attempts: z.nullable(z.number().int()),
    verifiedAtClient: z.nullable(z.string()).optional(),
  })
  .transform(v => {
    return remap$(v, {
      expireAt: 'expire_at',
      verifiedAtClient: 'verified_at_client',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FromOAuth$ {
  /** @deprecated use `FromOAuth$inboundSchema` instead. */
  export const inboundSchema = FromOAuth$inboundSchema;
  /** @deprecated use `FromOAuth$outboundSchema` instead. */
  export const outboundSchema = FromOAuth$outboundSchema;
  /** @deprecated use `FromOAuth$Outbound` instead. */
  export type Outbound = FromOAuth$Outbound;
}

export function fromOAuthToJSON(fromOAuth: FromOAuth): string {
  return JSON.stringify(FromOAuth$outboundSchema.parse(fromOAuth));
}

export function fromOAuthFromJSON(jsonString: string): SafeParseResult<FromOAuth, SDKValidationError> {
  return safeParse(
    jsonString,
    x => FromOAuth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FromOAuth' from JSON`,
  );
}

/** @internal */
export const AdminVerificationStatus$inboundSchema: z.ZodNativeEnum<typeof AdminVerificationStatus> =
  z.nativeEnum(AdminVerificationStatus);

/** @internal */
export const AdminVerificationStatus$outboundSchema: z.ZodNativeEnum<typeof AdminVerificationStatus> =
  AdminVerificationStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AdminVerificationStatus$ {
  /** @deprecated use `AdminVerificationStatus$inboundSchema` instead. */
  export const inboundSchema = AdminVerificationStatus$inboundSchema;
  /** @deprecated use `AdminVerificationStatus$outboundSchema` instead. */
  export const outboundSchema = AdminVerificationStatus$outboundSchema;
}

/** @internal */
export const VerificationStrategy$inboundSchema: z.ZodType<VerificationStrategy, z.ZodTypeDef, unknown> = z.union([
  z.nativeEnum(VerificationStrategy),
  z.string().transform(catchUnrecognizedEnum),
]);

/** @internal */
export const VerificationStrategy$outboundSchema: z.ZodType<VerificationStrategy, z.ZodTypeDef, VerificationStrategy> =
  z.union([z.nativeEnum(VerificationStrategy), z.string().and(z.custom<Unrecognized<string>>())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace VerificationStrategy$ {
  /** @deprecated use `VerificationStrategy$inboundSchema` instead. */
  export const inboundSchema = VerificationStrategy$inboundSchema;
  /** @deprecated use `VerificationStrategy$outboundSchema` instead. */
  export const outboundSchema = VerificationStrategy$outboundSchema;
}

/** @internal */
export const Admin$inboundSchema: z.ZodType<Admin, z.ZodTypeDef, unknown> = z
  .object({
    status: AdminVerificationStatus$inboundSchema,
    strategy: VerificationStrategy$inboundSchema,
    attempts: z.nullable(z.number().int()),
    expire_at: z.nullable(z.number().int()),
    verified_at_client: z.nullable(z.string()).optional(),
  })
  .transform(v => {
    return remap$(v, {
      expire_at: 'expireAt',
      verified_at_client: 'verifiedAtClient',
    });
  });

/** @internal */
export type Admin$Outbound = {
  status: string;
  strategy: string;
  attempts: number | null;
  expire_at: number | null;
  verified_at_client?: string | null | undefined;
};

/** @internal */
export const Admin$outboundSchema: z.ZodType<Admin$Outbound, z.ZodTypeDef, Admin> = z
  .object({
    status: AdminVerificationStatus$outboundSchema,
    strategy: VerificationStrategy$outboundSchema,
    attempts: z.nullable(z.number().int()),
    expireAt: z.nullable(z.number().int()),
    verifiedAtClient: z.nullable(z.string()).optional(),
  })
  .transform(v => {
    return remap$(v, {
      expireAt: 'expire_at',
      verifiedAtClient: 'verified_at_client',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Admin$ {
  /** @deprecated use `Admin$inboundSchema` instead. */
  export const inboundSchema = Admin$inboundSchema;
  /** @deprecated use `Admin$outboundSchema` instead. */
  export const outboundSchema = Admin$outboundSchema;
  /** @deprecated use `Admin$Outbound` instead. */
  export type Outbound = Admin$Outbound;
}

export function adminToJSON(admin: Admin): string {
  return JSON.stringify(Admin$outboundSchema.parse(admin));
}

export function adminFromJSON(jsonString: string): SafeParseResult<Admin, SDKValidationError> {
  return safeParse(jsonString, x => Admin$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Admin' from JSON`);
}

/** @internal */
export const VerificationStatus$inboundSchema: z.ZodNativeEnum<typeof VerificationStatus> =
  z.nativeEnum(VerificationStatus);

/** @internal */
export const VerificationStatus$outboundSchema: z.ZodNativeEnum<typeof VerificationStatus> =
  VerificationStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace VerificationStatus$ {
  /** @deprecated use `VerificationStatus$inboundSchema` instead. */
  export const inboundSchema = VerificationStatus$inboundSchema;
  /** @deprecated use `VerificationStatus$outboundSchema` instead. */
  export const outboundSchema = VerificationStatus$outboundSchema;
}

/** @internal */
export const Strategy$inboundSchema: z.ZodType<Strategy, z.ZodTypeDef, unknown> = z.union([
  z.nativeEnum(Strategy),
  z.string().transform(catchUnrecognizedEnum),
]);

/** @internal */
export const Strategy$outboundSchema: z.ZodType<Strategy, z.ZodTypeDef, Strategy> = z.union([
  z.nativeEnum(Strategy),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Strategy$ {
  /** @deprecated use `Strategy$inboundSchema` instead. */
  export const inboundSchema = Strategy$inboundSchema;
  /** @deprecated use `Strategy$outboundSchema` instead. */
  export const outboundSchema = Strategy$outboundSchema;
}

/** @internal */
export const Otp$inboundSchema: z.ZodType<Otp, z.ZodTypeDef, unknown> = z
  .object({
    status: VerificationStatus$inboundSchema,
    strategy: Strategy$inboundSchema,
    attempts: z.nullable(z.number().int()),
    expire_at: z.nullable(z.number().int()),
    verified_at_client: z.nullable(z.string()).optional(),
  })
  .transform(v => {
    return remap$(v, {
      expire_at: 'expireAt',
      verified_at_client: 'verifiedAtClient',
    });
  });

/** @internal */
export type Otp$Outbound = {
  status: string;
  strategy: string;
  attempts: number | null;
  expire_at: number | null;
  verified_at_client?: string | null | undefined;
};

/** @internal */
export const Otp$outboundSchema: z.ZodType<Otp$Outbound, z.ZodTypeDef, Otp> = z
  .object({
    status: VerificationStatus$outboundSchema,
    strategy: Strategy$outboundSchema,
    attempts: z.nullable(z.number().int()),
    expireAt: z.nullable(z.number().int()),
    verifiedAtClient: z.nullable(z.string()).optional(),
  })
  .transform(v => {
    return remap$(v, {
      expireAt: 'expire_at',
      verifiedAtClient: 'verified_at_client',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Otp$ {
  /** @deprecated use `Otp$inboundSchema` instead. */
  export const inboundSchema = Otp$inboundSchema;
  /** @deprecated use `Otp$outboundSchema` instead. */
  export const outboundSchema = Otp$outboundSchema;
  /** @deprecated use `Otp$Outbound` instead. */
  export type Outbound = Otp$Outbound;
}

export function otpToJSON(otp: Otp): string {
  return JSON.stringify(Otp$outboundSchema.parse(otp));
}

export function otpFromJSON(jsonString: string): SafeParseResult<Otp, SDKValidationError> {
  return safeParse(jsonString, x => Otp$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Otp' from JSON`);
}

/** @internal */
export const Verification$inboundSchema: z.ZodType<Verification, z.ZodTypeDef, unknown> = z.union([
  z.lazy(() => Otp$inboundSchema),
  z.lazy(() => Admin$inboundSchema),
  z.lazy(() => Ticket$inboundSchema),
  z.lazy(() => FromOAuth$inboundSchema),
]);

/** @internal */
export type Verification$Outbound = Otp$Outbound | Admin$Outbound | Ticket$Outbound | FromOAuth$Outbound;

/** @internal */
export const Verification$outboundSchema: z.ZodType<Verification$Outbound, z.ZodTypeDef, Verification> = z.union([
  z.lazy(() => Otp$outboundSchema),
  z.lazy(() => Admin$outboundSchema),
  z.lazy(() => Ticket$outboundSchema),
  z.lazy(() => FromOAuth$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Verification$ {
  /** @deprecated use `Verification$inboundSchema` instead. */
  export const inboundSchema = Verification$inboundSchema;
  /** @deprecated use `Verification$outboundSchema` instead. */
  export const outboundSchema = Verification$outboundSchema;
  /** @deprecated use `Verification$Outbound` instead. */
  export type Outbound = Verification$Outbound;
}

export function verificationToJSON(verification: Verification): string {
  return JSON.stringify(Verification$outboundSchema.parse(verification));
}

export function verificationFromJSON(jsonString: string): SafeParseResult<Verification, SDKValidationError> {
  return safeParse(
    jsonString,
    x => Verification$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Verification' from JSON`,
  );
}

/** @internal */
export const EmailAddress$inboundSchema: z.ZodType<EmailAddress, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string().optional(),
    object: EmailAddressObject$inboundSchema,
    email_address: z.string(),
    reserved: z.boolean(),
    verification: z.nullable(
      z.union([
        z.lazy(() => Otp$inboundSchema),
        z.lazy(() => Admin$inboundSchema),
        z.lazy(() => Ticket$inboundSchema),
        z.lazy(() => FromOAuth$inboundSchema),
      ]),
    ),
    linked_to: z.array(IdentificationLink$inboundSchema),
    matches_sso_connection: z.boolean().optional(),
    created_at: z.number().int(),
    updated_at: z.number().int(),
  })
  .transform(v => {
    return remap$(v, {
      email_address: 'emailAddress',
      linked_to: 'linkedTo',
      matches_sso_connection: 'matchesSsoConnection',
      created_at: 'createdAt',
      updated_at: 'updatedAt',
    });
  });

/** @internal */
export type EmailAddress$Outbound = {
  id?: string | undefined;
  object: string;
  email_address: string;
  reserved: boolean;
  verification: Otp$Outbound | Admin$Outbound | Ticket$Outbound | FromOAuth$Outbound | null;
  linked_to: Array<IdentificationLink$Outbound>;
  matches_sso_connection?: boolean | undefined;
  created_at: number;
  updated_at: number;
};

/** @internal */
export const EmailAddress$outboundSchema: z.ZodType<EmailAddress$Outbound, z.ZodTypeDef, EmailAddress> = z
  .object({
    id: z.string().optional(),
    object: EmailAddressObject$outboundSchema,
    emailAddress: z.string(),
    reserved: z.boolean(),
    verification: z.nullable(
      z.union([
        z.lazy(() => Otp$outboundSchema),
        z.lazy(() => Admin$outboundSchema),
        z.lazy(() => Ticket$outboundSchema),
        z.lazy(() => FromOAuth$outboundSchema),
      ]),
    ),
    linkedTo: z.array(IdentificationLink$outboundSchema),
    matchesSsoConnection: z.boolean().optional(),
    createdAt: z.number().int(),
    updatedAt: z.number().int(),
  })
  .transform(v => {
    return remap$(v, {
      emailAddress: 'email_address',
      linkedTo: 'linked_to',
      matchesSsoConnection: 'matches_sso_connection',
      createdAt: 'created_at',
      updatedAt: 'updated_at',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EmailAddress$ {
  /** @deprecated use `EmailAddress$inboundSchema` instead. */
  export const inboundSchema = EmailAddress$inboundSchema;
  /** @deprecated use `EmailAddress$outboundSchema` instead. */
  export const outboundSchema = EmailAddress$outboundSchema;
  /** @deprecated use `EmailAddress$Outbound` instead. */
  export type Outbound = EmailAddress$Outbound;
}

export function emailAddressToJSON(emailAddress: EmailAddress): string {
  return JSON.stringify(EmailAddress$outboundSchema.parse(emailAddress));
}

export function emailAddressFromJSON(jsonString: string): SafeParseResult<EmailAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    x => EmailAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmailAddress' from JSON`,
  );
}
