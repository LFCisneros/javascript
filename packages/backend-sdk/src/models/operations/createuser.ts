/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type CreateUserRequestBody = {
  /**
   * The ID of the user as used in your external systems or your previous authentication solution.
   *
   * @remarks
   * Must be unique across your instance.
   */
  externalId?: string | null | undefined;
  /**
   * The first name to assign to the user
   */
  firstName?: string | null | undefined;
  /**
   * The last name to assign to the user
   */
  lastName?: string | null | undefined;
  /**
   * Email addresses to add to the user.
   *
   * @remarks
   * Must be unique across your instance.
   * The first email address will be set as the user's primary email address.
   */
  emailAddress?: Array<string> | undefined;
  /**
   * Phone numbers to add to the user.
   *
   * @remarks
   * Must be unique across your instance.
   * The first phone number will be set as the user's primary phone number.
   */
  phoneNumber?: Array<string> | undefined;
  /**
   * Web3 wallets to add to the user.
   *
   * @remarks
   * Must be unique across your instance.
   * The first wallet will be set as the user's primary wallet.
   */
  web3Wallet?: Array<string> | undefined;
  /**
   * The username to give to the user.
   *
   * @remarks
   * It must be unique across your instance.
   */
  username?: string | null | undefined;
  /**
   * The plaintext password to give the user.
   *
   * @remarks
   * Must be at least 8 characters long, and can not be in any list of hacked passwords.
   */
  password?: string | null | undefined;
  /**
   * In case you already have the password digests and not the passwords, you can use them for the newly created user via this property.
   *
   * @remarks
   * The digests should be generated with one of the supported algorithms.
   * The hashing algorithm can be specified using the `password_hasher` property.
   */
  passwordDigest?: string | null | undefined;
  /**
   * The hashing algorithm that was used to generate the password digest.
   *
   * @remarks
   *
   * The algorithms we support at the moment are [`bcrypt`](https://en.wikipedia.org/wiki/Bcrypt), [`bcrypt_sha256_django`](https://docs.djangoproject.com/en/4.0/topics/auth/passwords/), [`md5`](https://en.wikipedia.org/wiki/MD5), `pbkdf2_sha1`, `pbkdf2_sha256`, [`pbkdf2_sha256_django`](https://docs.djangoproject.com/en/4.0/topics/auth/passwords/),
   * [`phpass`](https://www.openwall.com/phpass/), [`scrypt_firebase`](https://firebaseopensource.com/projects/firebase/scrypt/),
   * [`scrypt_werkzeug`](https://werkzeug.palletsprojects.com/en/3.0.x/utils/#werkzeug.security.generate_password_hash), [`sha256`](https://en.wikipedia.org/wiki/SHA-2),
   * and the [`argon2`](https://argon2.online/) variants: `argon2i` and `argon2id`.
   *
   * Each of the supported hashers expects the incoming digest to be in a particular format. See the [Clerk docs](https://clerk.com/docs/references/backend/user/create-user) for more information.
   */
  passwordHasher?: string | undefined;
  /**
   * When set to `true` all password checks are skipped.
   *
   * @remarks
   * It is recommended to use this method only when migrating plaintext passwords to Clerk.
   * Upon migration the user base should be prompted to pick stronger password.
   */
  skipPasswordChecks?: boolean | null | undefined;
  /**
   * When set to `true`, `password` is not required anymore when creating the user and can be omitted.
   *
   * @remarks
   * This is useful when you are trying to create a user that doesn't have a password, in an instance that is using passwords.
   * Please note that you cannot use this flag if password is the only way for a user to sign into your instance.
   */
  skipPasswordRequirement?: boolean | null | undefined;
  /**
   * In case TOTP is configured on the instance, you can provide the secret to enable it on the newly created user without the need to reset it.
   *
   * @remarks
   * Please note that currently the supported options are:
   * * Period: 30 seconds
   * * Code length: 6 digits
   * * Algorithm: SHA1
   */
  totpSecret?: string | null | undefined;
  /**
   * If Backup Codes are configured on the instance, you can provide them to enable it on the newly created user without the need to reset them.
   *
   * @remarks
   * You must provide the backup codes in plain format or the corresponding bcrypt digest.
   */
  backupCodes?: Array<string> | undefined;
  /**
   * Metadata saved on the user, that is visible to both your Frontend and Backend APIs
   */
  publicMetadata?: { [k: string]: any } | undefined;
  /**
   * Metadata saved on the user, that is only visible to your Backend API
   */
  privateMetadata?: { [k: string]: any } | undefined;
  /**
   * Metadata saved on the user, that can be updated from both the Frontend and Backend APIs.
   *
   * @remarks
   * Note: Since this data can be modified from the frontend, it is not guaranteed to be safe.
   */
  unsafeMetadata?: { [k: string]: any } | undefined;
  /**
   * If enabled, user can delete themselves via FAPI.
   *
   * @remarks
   */
  deleteSelfEnabled?: boolean | null | undefined;
  /**
   * A custom timestamp denoting _when_ the user accepted legal requirements, specified in RFC3339 format (e.g. `2012-10-20T07:15:20.902Z`).
   */
  legalAcceptedAt?: string | null | undefined;
  /**
   * When set to `true` all legal checks are skipped.
   *
   * @remarks
   * It is not recommended to skip legal checks unless you are migrating a user to Clerk.
   */
  skipLegalChecks?: boolean | null | undefined;
  /**
   * If enabled, user can create organizations via FAPI.
   *
   * @remarks
   */
  createOrganizationEnabled?: boolean | null | undefined;
  /**
   * The maximum number of organizations the user can create. 0 means unlimited.
   *
   * @remarks
   */
  createOrganizationsLimit?: number | null | undefined;
  /**
   * A custom date/time denoting _when_ the user signed up to the application, specified in RFC3339 format (e.g. `2012-10-20T07:15:20.902Z`).
   */
  createdAt?: string | null | undefined;
};

/** @internal */
export const CreateUserRequestBody$inboundSchema: z.ZodType<CreateUserRequestBody, z.ZodTypeDef, unknown> = z
  .object({
    external_id: z.nullable(z.string()).optional(),
    first_name: z.nullable(z.string()).optional(),
    last_name: z.nullable(z.string()).optional(),
    email_address: z.array(z.string()).optional(),
    phone_number: z.array(z.string()).optional(),
    web3_wallet: z.array(z.string()).optional(),
    username: z.nullable(z.string()).optional(),
    password: z.nullable(z.string()).optional(),
    password_digest: z.nullable(z.string()).optional(),
    password_hasher: z.string().optional(),
    skip_password_checks: z.nullable(z.boolean()).optional(),
    skip_password_requirement: z.nullable(z.boolean()).optional(),
    totp_secret: z.nullable(z.string()).optional(),
    backup_codes: z.array(z.string()).optional(),
    public_metadata: z.record(z.any()).optional(),
    private_metadata: z.record(z.any()).optional(),
    unsafe_metadata: z.record(z.any()).optional(),
    delete_self_enabled: z.nullable(z.boolean()).optional(),
    legal_accepted_at: z.nullable(z.string()).optional(),
    skip_legal_checks: z.nullable(z.boolean()).optional(),
    create_organization_enabled: z.nullable(z.boolean()).optional(),
    create_organizations_limit: z.nullable(z.number().int()).optional(),
    created_at: z.nullable(z.string()).optional(),
  })
  .transform(v => {
    return remap$(v, {
      external_id: 'externalId',
      first_name: 'firstName',
      last_name: 'lastName',
      email_address: 'emailAddress',
      phone_number: 'phoneNumber',
      web3_wallet: 'web3Wallet',
      password_digest: 'passwordDigest',
      password_hasher: 'passwordHasher',
      skip_password_checks: 'skipPasswordChecks',
      skip_password_requirement: 'skipPasswordRequirement',
      totp_secret: 'totpSecret',
      backup_codes: 'backupCodes',
      public_metadata: 'publicMetadata',
      private_metadata: 'privateMetadata',
      unsafe_metadata: 'unsafeMetadata',
      delete_self_enabled: 'deleteSelfEnabled',
      legal_accepted_at: 'legalAcceptedAt',
      skip_legal_checks: 'skipLegalChecks',
      create_organization_enabled: 'createOrganizationEnabled',
      create_organizations_limit: 'createOrganizationsLimit',
      created_at: 'createdAt',
    });
  });

/** @internal */
export type CreateUserRequestBody$Outbound = {
  external_id?: string | null | undefined;
  first_name?: string | null | undefined;
  last_name?: string | null | undefined;
  email_address?: Array<string> | undefined;
  phone_number?: Array<string> | undefined;
  web3_wallet?: Array<string> | undefined;
  username?: string | null | undefined;
  password?: string | null | undefined;
  password_digest?: string | null | undefined;
  password_hasher?: string | undefined;
  skip_password_checks?: boolean | null | undefined;
  skip_password_requirement?: boolean | null | undefined;
  totp_secret?: string | null | undefined;
  backup_codes?: Array<string> | undefined;
  public_metadata?: { [k: string]: any } | undefined;
  private_metadata?: { [k: string]: any } | undefined;
  unsafe_metadata?: { [k: string]: any } | undefined;
  delete_self_enabled?: boolean | null | undefined;
  legal_accepted_at?: string | null | undefined;
  skip_legal_checks?: boolean | null | undefined;
  create_organization_enabled?: boolean | null | undefined;
  create_organizations_limit?: number | null | undefined;
  created_at?: string | null | undefined;
};

/** @internal */
export const CreateUserRequestBody$outboundSchema: z.ZodType<
  CreateUserRequestBody$Outbound,
  z.ZodTypeDef,
  CreateUserRequestBody
> = z
  .object({
    externalId: z.nullable(z.string()).optional(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    emailAddress: z.array(z.string()).optional(),
    phoneNumber: z.array(z.string()).optional(),
    web3Wallet: z.array(z.string()).optional(),
    username: z.nullable(z.string()).optional(),
    password: z.nullable(z.string()).optional(),
    passwordDigest: z.nullable(z.string()).optional(),
    passwordHasher: z.string().optional(),
    skipPasswordChecks: z.nullable(z.boolean()).optional(),
    skipPasswordRequirement: z.nullable(z.boolean()).optional(),
    totpSecret: z.nullable(z.string()).optional(),
    backupCodes: z.array(z.string()).optional(),
    publicMetadata: z.record(z.any()).optional(),
    privateMetadata: z.record(z.any()).optional(),
    unsafeMetadata: z.record(z.any()).optional(),
    deleteSelfEnabled: z.nullable(z.boolean()).optional(),
    legalAcceptedAt: z.nullable(z.string()).optional(),
    skipLegalChecks: z.nullable(z.boolean()).optional(),
    createOrganizationEnabled: z.nullable(z.boolean()).optional(),
    createOrganizationsLimit: z.nullable(z.number().int()).optional(),
    createdAt: z.nullable(z.string()).optional(),
  })
  .transform(v => {
    return remap$(v, {
      externalId: 'external_id',
      firstName: 'first_name',
      lastName: 'last_name',
      emailAddress: 'email_address',
      phoneNumber: 'phone_number',
      web3Wallet: 'web3_wallet',
      passwordDigest: 'password_digest',
      passwordHasher: 'password_hasher',
      skipPasswordChecks: 'skip_password_checks',
      skipPasswordRequirement: 'skip_password_requirement',
      totpSecret: 'totp_secret',
      backupCodes: 'backup_codes',
      publicMetadata: 'public_metadata',
      privateMetadata: 'private_metadata',
      unsafeMetadata: 'unsafe_metadata',
      deleteSelfEnabled: 'delete_self_enabled',
      legalAcceptedAt: 'legal_accepted_at',
      skipLegalChecks: 'skip_legal_checks',
      createOrganizationEnabled: 'create_organization_enabled',
      createOrganizationsLimit: 'create_organizations_limit',
      createdAt: 'created_at',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateUserRequestBody$ {
  /** @deprecated use `CreateUserRequestBody$inboundSchema` instead. */
  export const inboundSchema = CreateUserRequestBody$inboundSchema;
  /** @deprecated use `CreateUserRequestBody$outboundSchema` instead. */
  export const outboundSchema = CreateUserRequestBody$outboundSchema;
  /** @deprecated use `CreateUserRequestBody$Outbound` instead. */
  export type Outbound = CreateUserRequestBody$Outbound;
}

export function createUserRequestBodyToJSON(createUserRequestBody: CreateUserRequestBody): string {
  return JSON.stringify(CreateUserRequestBody$outboundSchema.parse(createUserRequestBody));
}

export function createUserRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateUserRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    x => CreateUserRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateUserRequestBody' from JSON`,
  );
}
