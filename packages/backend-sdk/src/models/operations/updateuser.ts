/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type UpdateUserRequestBody = {
  /**
   * The ID of the user as used in your external systems or your previous authentication solution.
   *
   * @remarks
   * Must be unique across your instance.
   */
  externalId?: string | null | undefined;
  /**
   * The first name to assign to the user
   */
  firstName?: string | null | undefined;
  /**
   * The last name to assign to the user
   */
  lastName?: string | null | undefined;
  /**
   * The ID of the email address to set as primary.
   *
   * @remarks
   * It must be verified, and present on the current user.
   */
  primaryEmailAddressId?: string | null | undefined;
  /**
   * If set to `true`, the user will be notified that their primary email address has changed.
   *
   * @remarks
   * By default, no notification is sent.
   */
  notifyPrimaryEmailAddressChanged?: boolean | null | undefined;
  /**
   * The ID of the phone number to set as primary.
   *
   * @remarks
   * It must be verified, and present on the current user.
   */
  primaryPhoneNumberId?: string | null | undefined;
  /**
   * The ID of the web3 wallets to set as primary.
   *
   * @remarks
   * It must be verified, and present on the current user.
   */
  primaryWeb3WalletId?: string | null | undefined;
  /**
   * The username to give to the user.
   *
   * @remarks
   * It must be unique across your instance.
   */
  username?: string | null | undefined;
  /**
   * The ID of the image to set as the user's profile image
   */
  profileImageId?: string | null | undefined;
  /**
   * The plaintext password to give the user.
   *
   * @remarks
   * Must be at least 8 characters long, and can not be in any list of hacked passwords.
   */
  password?: string | null | undefined;
  /**
   * In case you already have the password digests and not the passwords, you can use them for the newly created user via this property.
   *
   * @remarks
   * The digests should be generated with one of the supported algorithms.
   * The hashing algorithm can be specified using the `password_hasher` property.
   */
  passwordDigest?: string | undefined;
  /**
   * The hashing algorithm that was used to generate the password digest.
   *
   * @remarks
   *
   * The algorithms we support at the moment are [`bcrypt`](https://en.wikipedia.org/wiki/Bcrypt), [`bcrypt_sha256_django`](https://docs.djangoproject.com/en/4.0/topics/auth/passwords/), [`md5`](https://en.wikipedia.org/wiki/MD5), `pbkdf2_sha1`, `pbkdf2_sha256`, [`pbkdf2_sha256_django`](https://docs.djangoproject.com/en/4.0/topics/auth/passwords/),
   * [`phpass`](https://www.openwall.com/phpass/), [`scrypt_firebase`](https://firebaseopensource.com/projects/firebase/scrypt/),
   * [`scrypt_werkzeug`](https://werkzeug.palletsprojects.com/en/3.0.x/utils/#werkzeug.security.generate_password_hash), [`sha256`](https://en.wikipedia.org/wiki/SHA-2),
   * and the [`argon2`](https://argon2.online/) variants: `argon2i` and `argon2id`.
   *
   * Each of the supported hashers expects the incoming digest to be in a particular format. See the [Clerk docs](https://clerk.com/docs/references/backend/user/create-user) for more information.
   */
  passwordHasher?: string | undefined;
  /**
   * Set it to `true` if you're updating the user's password and want to skip any password policy settings check. This parameter can only be used when providing a `password`.
   */
  skipPasswordChecks?: boolean | null | undefined;
  /**
   * Set to `true` to sign out the user from all their active sessions once their password is updated. This parameter can only be used when providing a `password`.
   */
  signOutOfOtherSessions?: boolean | null | undefined;
  /**
   * In case TOTP is configured on the instance, you can provide the secret to enable it on the specific user without the need to reset it.
   *
   * @remarks
   * Please note that currently the supported options are:
   * * Period: 30 seconds
   * * Code length: 6 digits
   * * Algorithm: SHA1
   */
  totpSecret?: string | null | undefined;
  /**
   * If Backup Codes are configured on the instance, you can provide them to enable it on the specific user without the need to reset them.
   *
   * @remarks
   * You must provide the backup codes in plain format or the corresponding bcrypt digest.
   */
  backupCodes?: Array<string> | undefined;
  /**
   * Metadata saved on the user, that is visible to both your Frontend and Backend APIs
   */
  publicMetadata?: { [k: string]: any } | null | undefined;
  /**
   * Metadata saved on the user, that is only visible to your Backend API
   */
  privateMetadata?: { [k: string]: any } | null | undefined;
  /**
   * Metadata saved on the user, that can be updated from both the Frontend and Backend APIs.
   *
   * @remarks
   * Note: Since this data can be modified from the frontend, it is not guaranteed to be safe.
   */
  unsafeMetadata?: { [k: string]: any } | null | undefined;
  /**
   * If true, the user can delete themselves with the Frontend API.
   */
  deleteSelfEnabled?: boolean | null | undefined;
  /**
   * If true, the user can create organizations with the Frontend API.
   */
  createOrganizationEnabled?: boolean | null | undefined;
  /**
   * A custom timestamps denoting _when_ the user accepted legal requirements, specified in RFC3339 format (e.g. `2012-10-20T07:15:20.902Z`).
   */
  legalAcceptedAt?: string | null | undefined;
  /**
   * When set to `true` all legal checks are skipped.
   *
   * @remarks
   * It is not recommended to skip legal checks unless you are migrating a user to Clerk.
   */
  skipLegalChecks?: boolean | null | undefined;
  /**
   * The maximum number of organizations the user can create. 0 means unlimited.
   */
  createOrganizationsLimit?: number | null | undefined;
  /**
   * A custom date/time denoting _when_ the user signed up to the application, specified in RFC3339 format (e.g. `2012-10-20T07:15:20.902Z`).
   */
  createdAt?: string | null | undefined;
};

export type UpdateUserRequest = {
  /**
   * The ID of the user to update
   */
  userId: string;
  requestBody: UpdateUserRequestBody;
};

/** @internal */
export const UpdateUserRequestBody$inboundSchema: z.ZodType<
  UpdateUserRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  external_id: z.nullable(z.string()).optional(),
  first_name: z.nullable(z.string()).optional(),
  last_name: z.nullable(z.string()).optional(),
  primary_email_address_id: z.nullable(z.string()).optional(),
  notify_primary_email_address_changed: z.nullable(z.boolean().default(false)),
  primary_phone_number_id: z.nullable(z.string()).optional(),
  primary_web3_wallet_id: z.nullable(z.string()).optional(),
  username: z.nullable(z.string()).optional(),
  profile_image_id: z.nullable(z.string()).optional(),
  password: z.nullable(z.string()).optional(),
  password_digest: z.string().optional(),
  password_hasher: z.string().optional(),
  skip_password_checks: z.nullable(z.boolean()).optional(),
  sign_out_of_other_sessions: z.nullable(z.boolean()).optional(),
  totp_secret: z.nullable(z.string()).optional(),
  backup_codes: z.array(z.string()).optional(),
  public_metadata: z.nullable(z.record(z.any())).optional(),
  private_metadata: z.nullable(z.record(z.any())).optional(),
  unsafe_metadata: z.nullable(z.record(z.any())).optional(),
  delete_self_enabled: z.nullable(z.boolean()).optional(),
  create_organization_enabled: z.nullable(z.boolean()).optional(),
  legal_accepted_at: z.nullable(z.string()).optional(),
  skip_legal_checks: z.nullable(z.boolean()).optional(),
  create_organizations_limit: z.nullable(z.number().int()).optional(),
  created_at: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "external_id": "externalId",
    "first_name": "firstName",
    "last_name": "lastName",
    "primary_email_address_id": "primaryEmailAddressId",
    "notify_primary_email_address_changed": "notifyPrimaryEmailAddressChanged",
    "primary_phone_number_id": "primaryPhoneNumberId",
    "primary_web3_wallet_id": "primaryWeb3WalletId",
    "profile_image_id": "profileImageId",
    "password_digest": "passwordDigest",
    "password_hasher": "passwordHasher",
    "skip_password_checks": "skipPasswordChecks",
    "sign_out_of_other_sessions": "signOutOfOtherSessions",
    "totp_secret": "totpSecret",
    "backup_codes": "backupCodes",
    "public_metadata": "publicMetadata",
    "private_metadata": "privateMetadata",
    "unsafe_metadata": "unsafeMetadata",
    "delete_self_enabled": "deleteSelfEnabled",
    "create_organization_enabled": "createOrganizationEnabled",
    "legal_accepted_at": "legalAcceptedAt",
    "skip_legal_checks": "skipLegalChecks",
    "create_organizations_limit": "createOrganizationsLimit",
    "created_at": "createdAt",
  });
});

/** @internal */
export type UpdateUserRequestBody$Outbound = {
  external_id?: string | null | undefined;
  first_name?: string | null | undefined;
  last_name?: string | null | undefined;
  primary_email_address_id?: string | null | undefined;
  notify_primary_email_address_changed: boolean | null;
  primary_phone_number_id?: string | null | undefined;
  primary_web3_wallet_id?: string | null | undefined;
  username?: string | null | undefined;
  profile_image_id?: string | null | undefined;
  password?: string | null | undefined;
  password_digest?: string | undefined;
  password_hasher?: string | undefined;
  skip_password_checks?: boolean | null | undefined;
  sign_out_of_other_sessions?: boolean | null | undefined;
  totp_secret?: string | null | undefined;
  backup_codes?: Array<string> | undefined;
  public_metadata?: { [k: string]: any } | null | undefined;
  private_metadata?: { [k: string]: any } | null | undefined;
  unsafe_metadata?: { [k: string]: any } | null | undefined;
  delete_self_enabled?: boolean | null | undefined;
  create_organization_enabled?: boolean | null | undefined;
  legal_accepted_at?: string | null | undefined;
  skip_legal_checks?: boolean | null | undefined;
  create_organizations_limit?: number | null | undefined;
  created_at?: string | null | undefined;
};

/** @internal */
export const UpdateUserRequestBody$outboundSchema: z.ZodType<
  UpdateUserRequestBody$Outbound,
  z.ZodTypeDef,
  UpdateUserRequestBody
> = z.object({
  externalId: z.nullable(z.string()).optional(),
  firstName: z.nullable(z.string()).optional(),
  lastName: z.nullable(z.string()).optional(),
  primaryEmailAddressId: z.nullable(z.string()).optional(),
  notifyPrimaryEmailAddressChanged: z.nullable(z.boolean().default(false)),
  primaryPhoneNumberId: z.nullable(z.string()).optional(),
  primaryWeb3WalletId: z.nullable(z.string()).optional(),
  username: z.nullable(z.string()).optional(),
  profileImageId: z.nullable(z.string()).optional(),
  password: z.nullable(z.string()).optional(),
  passwordDigest: z.string().optional(),
  passwordHasher: z.string().optional(),
  skipPasswordChecks: z.nullable(z.boolean()).optional(),
  signOutOfOtherSessions: z.nullable(z.boolean()).optional(),
  totpSecret: z.nullable(z.string()).optional(),
  backupCodes: z.array(z.string()).optional(),
  publicMetadata: z.nullable(z.record(z.any())).optional(),
  privateMetadata: z.nullable(z.record(z.any())).optional(),
  unsafeMetadata: z.nullable(z.record(z.any())).optional(),
  deleteSelfEnabled: z.nullable(z.boolean()).optional(),
  createOrganizationEnabled: z.nullable(z.boolean()).optional(),
  legalAcceptedAt: z.nullable(z.string()).optional(),
  skipLegalChecks: z.nullable(z.boolean()).optional(),
  createOrganizationsLimit: z.nullable(z.number().int()).optional(),
  createdAt: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    externalId: "external_id",
    firstName: "first_name",
    lastName: "last_name",
    primaryEmailAddressId: "primary_email_address_id",
    notifyPrimaryEmailAddressChanged: "notify_primary_email_address_changed",
    primaryPhoneNumberId: "primary_phone_number_id",
    primaryWeb3WalletId: "primary_web3_wallet_id",
    profileImageId: "profile_image_id",
    passwordDigest: "password_digest",
    passwordHasher: "password_hasher",
    skipPasswordChecks: "skip_password_checks",
    signOutOfOtherSessions: "sign_out_of_other_sessions",
    totpSecret: "totp_secret",
    backupCodes: "backup_codes",
    publicMetadata: "public_metadata",
    privateMetadata: "private_metadata",
    unsafeMetadata: "unsafe_metadata",
    deleteSelfEnabled: "delete_self_enabled",
    createOrganizationEnabled: "create_organization_enabled",
    legalAcceptedAt: "legal_accepted_at",
    skipLegalChecks: "skip_legal_checks",
    createOrganizationsLimit: "create_organizations_limit",
    createdAt: "created_at",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateUserRequestBody$ {
  /** @deprecated use `UpdateUserRequestBody$inboundSchema` instead. */
  export const inboundSchema = UpdateUserRequestBody$inboundSchema;
  /** @deprecated use `UpdateUserRequestBody$outboundSchema` instead. */
  export const outboundSchema = UpdateUserRequestBody$outboundSchema;
  /** @deprecated use `UpdateUserRequestBody$Outbound` instead. */
  export type Outbound = UpdateUserRequestBody$Outbound;
}

export function updateUserRequestBodyToJSON(
  updateUserRequestBody: UpdateUserRequestBody,
): string {
  return JSON.stringify(
    UpdateUserRequestBody$outboundSchema.parse(updateUserRequestBody),
  );
}

export function updateUserRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateUserRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateUserRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateUserRequestBody' from JSON`,
  );
}

/** @internal */
export const UpdateUserRequest$inboundSchema: z.ZodType<
  UpdateUserRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  user_id: z.string(),
  RequestBody: z.lazy(() => UpdateUserRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "user_id": "userId",
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type UpdateUserRequest$Outbound = {
  user_id: string;
  RequestBody: UpdateUserRequestBody$Outbound;
};

/** @internal */
export const UpdateUserRequest$outboundSchema: z.ZodType<
  UpdateUserRequest$Outbound,
  z.ZodTypeDef,
  UpdateUserRequest
> = z.object({
  userId: z.string(),
  requestBody: z.lazy(() => UpdateUserRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    userId: "user_id",
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateUserRequest$ {
  /** @deprecated use `UpdateUserRequest$inboundSchema` instead. */
  export const inboundSchema = UpdateUserRequest$inboundSchema;
  /** @deprecated use `UpdateUserRequest$outboundSchema` instead. */
  export const outboundSchema = UpdateUserRequest$outboundSchema;
  /** @deprecated use `UpdateUserRequest$Outbound` instead. */
  export type Outbound = UpdateUserRequest$Outbound;
}

export function updateUserRequestToJSON(
  updateUserRequest: UpdateUserRequest,
): string {
  return JSON.stringify(
    UpdateUserRequest$outboundSchema.parse(updateUserRequest),
  );
}

export function updateUserRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdateUserRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateUserRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateUserRequest' from JSON`,
  );
}
