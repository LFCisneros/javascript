/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type GetOAuthAccessTokenRequest = {
  /**
   * The ID of the user for which to retrieve the OAuth access token
   */
  userId: string;
  /**
   * The ID of the OAuth provider (e.g. `oauth_google`)
   */
  provider: string;
  /**
   * Whether to paginate the results.
   *
   * @remarks
   * If true, the results will be paginated.
   * If false, the results will not be paginated.
   */
  paginated?: boolean | undefined;
  /**
   * Applies a limit to the number of results returned.
   *
   * @remarks
   * Can be used for paginating the results together with `offset`.
   */
  limit?: number | undefined;
  /**
   * Skip the first `offset` results when paginating.
   *
   * @remarks
   * Needs to be an integer greater or equal to zero.
   * To be used in conjunction with `limit`.
   */
  offset?: number | undefined;
};

export type ResponseBody = {
  object?: string | undefined;
  /**
   * External account ID
   */
  externalAccountId?: string | undefined;
  /**
   * The unique ID of the user in the external provider's system
   */
  providerUserId?: string | undefined;
  /**
   * The access token
   */
  token?: string | undefined;
  /**
   * The ID of the provider
   */
  provider?: string | undefined;
  publicMetadata?: { [k: string]: any } | undefined;
  label?: string | null | undefined;
  /**
   * The list of scopes that the token is valid for.
   *
   * @remarks
   * Only present for OAuth 2.0 tokens.
   */
  scopes?: Array<string> | undefined;
  /**
   * The token secret. Only present for OAuth 1.0 tokens.
   */
  tokenSecret?: string | undefined;
  /**
   * Unix timestamp of the access token expiration.
   */
  expiresAt?: number | null | undefined;
};

/** @internal */
export const GetOAuthAccessTokenRequest$inboundSchema: z.ZodType<GetOAuthAccessTokenRequest, z.ZodTypeDef, unknown> = z
  .object({
    user_id: z.string(),
    provider: z.string(),
    paginated: z.boolean().optional(),
    limit: z.number().int().default(10),
    offset: z.number().int().default(0),
  })
  .transform(v => {
    return remap$(v, {
      user_id: 'userId',
    });
  });

/** @internal */
export type GetOAuthAccessTokenRequest$Outbound = {
  user_id: string;
  provider: string;
  paginated?: boolean | undefined;
  limit: number;
  offset: number;
};

/** @internal */
export const GetOAuthAccessTokenRequest$outboundSchema: z.ZodType<
  GetOAuthAccessTokenRequest$Outbound,
  z.ZodTypeDef,
  GetOAuthAccessTokenRequest
> = z
  .object({
    userId: z.string(),
    provider: z.string(),
    paginated: z.boolean().optional(),
    limit: z.number().int().default(10),
    offset: z.number().int().default(0),
  })
  .transform(v => {
    return remap$(v, {
      userId: 'user_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetOAuthAccessTokenRequest$ {
  /** @deprecated use `GetOAuthAccessTokenRequest$inboundSchema` instead. */
  export const inboundSchema = GetOAuthAccessTokenRequest$inboundSchema;
  /** @deprecated use `GetOAuthAccessTokenRequest$outboundSchema` instead. */
  export const outboundSchema = GetOAuthAccessTokenRequest$outboundSchema;
  /** @deprecated use `GetOAuthAccessTokenRequest$Outbound` instead. */
  export type Outbound = GetOAuthAccessTokenRequest$Outbound;
}

export function getOAuthAccessTokenRequestToJSON(getOAuthAccessTokenRequest: GetOAuthAccessTokenRequest): string {
  return JSON.stringify(GetOAuthAccessTokenRequest$outboundSchema.parse(getOAuthAccessTokenRequest));
}

export function getOAuthAccessTokenRequestFromJSON(
  jsonString: string,
): SafeParseResult<GetOAuthAccessTokenRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    x => GetOAuthAccessTokenRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetOAuthAccessTokenRequest' from JSON`,
  );
}

/** @internal */
export const ResponseBody$inboundSchema: z.ZodType<ResponseBody, z.ZodTypeDef, unknown> = z
  .object({
    object: z.string().optional(),
    external_account_id: z.string().optional(),
    provider_user_id: z.string().optional(),
    token: z.string().optional(),
    provider: z.string().optional(),
    public_metadata: z.record(z.any()).optional(),
    label: z.nullable(z.string()).optional(),
    scopes: z.array(z.string()).optional(),
    token_secret: z.string().optional(),
    expires_at: z.nullable(z.number().int()).optional(),
  })
  .transform(v => {
    return remap$(v, {
      external_account_id: 'externalAccountId',
      provider_user_id: 'providerUserId',
      public_metadata: 'publicMetadata',
      token_secret: 'tokenSecret',
      expires_at: 'expiresAt',
    });
  });

/** @internal */
export type ResponseBody$Outbound = {
  object?: string | undefined;
  external_account_id?: string | undefined;
  provider_user_id?: string | undefined;
  token?: string | undefined;
  provider?: string | undefined;
  public_metadata?: { [k: string]: any } | undefined;
  label?: string | null | undefined;
  scopes?: Array<string> | undefined;
  token_secret?: string | undefined;
  expires_at?: number | null | undefined;
};

/** @internal */
export const ResponseBody$outboundSchema: z.ZodType<ResponseBody$Outbound, z.ZodTypeDef, ResponseBody> = z
  .object({
    object: z.string().optional(),
    externalAccountId: z.string().optional(),
    providerUserId: z.string().optional(),
    token: z.string().optional(),
    provider: z.string().optional(),
    publicMetadata: z.record(z.any()).optional(),
    label: z.nullable(z.string()).optional(),
    scopes: z.array(z.string()).optional(),
    tokenSecret: z.string().optional(),
    expiresAt: z.nullable(z.number().int()).optional(),
  })
  .transform(v => {
    return remap$(v, {
      externalAccountId: 'external_account_id',
      providerUserId: 'provider_user_id',
      publicMetadata: 'public_metadata',
      tokenSecret: 'token_secret',
      expiresAt: 'expires_at',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBody$ {
  /** @deprecated use `ResponseBody$inboundSchema` instead. */
  export const inboundSchema = ResponseBody$inboundSchema;
  /** @deprecated use `ResponseBody$outboundSchema` instead. */
  export const outboundSchema = ResponseBody$outboundSchema;
  /** @deprecated use `ResponseBody$Outbound` instead. */
  export type Outbound = ResponseBody$Outbound;
}

export function responseBodyToJSON(responseBody: ResponseBody): string {
  return JSON.stringify(ResponseBody$outboundSchema.parse(responseBody));
}

export function responseBodyFromJSON(jsonString: string): SafeParseResult<ResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    x => ResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBody' from JSON`,
  );
}
